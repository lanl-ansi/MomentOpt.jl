var documenterSearchIndex = {"docs":
[{"location":"gmp/#Generalized-Moment-Problems","page":"The Generalized Moment Problem","title":"Generalized Moment Problems","text":"","category":"section"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"The Generalized Moment Problem (GMP) as described in Lasserre (2009) is a linear optimization problem with countably many constraints in the space of measures. Formally, it takes the form","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"beginarrayc l\nmin_colorredmu_i  sum_i int colorbluef_i(x) dcolorredmu_i(x)\n sum_i int colorblueh_i^gamma(x)dcolorredmu_i(x) leq colorgreenb^gamma quad forall gamma inGamma\n textsupp(colorredmu_i)subseteq xinmathbbR^n  colorblueg_i^1(x)geq 0ldotscolorblueg_i^m_i(x)geq 0 \nendarray","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"where colorredmu_i are unkown (finite, positive, Borel) measures, Gamma is a countble set, and colorgreenb^gamma are given numbers. In order to be able to compute approximations to this problem we require colorbluef_i, colorblueh_i^gamma, and colorblueg_i^j to be polynomials.","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"Under some conditions a measure colorredmu supported on some set colorblueKsubseteq mathbbR^n is uniquely determined by its sequence of moments, defined by","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"colorredz_alpha = int_colorblueK x^alpha dcolorred mu(x)","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"where x^alpha = prod_i x_i^alpha_i. This is for example the case when colorblueK is compact, or when the sequence colorred(z_alpha)_alpha satisfies the socalled Carleman's condition. Therefore one is often interested in the sequences of moments, rather than the measure itself, motivating the name generalized MOMENT problem. ","category":"page"},{"location":"gmp/#Example:-Polynomial-Optimization","page":"The Generalized Moment Problem","title":"Example: Polynomial Optimization","text":"","category":"section"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"Given a polynomial colorbluef and a set colorblueK = xinmathbbR^n  colorblueg^1(x)geq 0ldotscolorblueg^m(x)geq 0  one is interested in the global minimum ","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"beginarrayc l\nmin_colorredx   colorbluef(colorredx)\n colorredxincolorblueK\nendarray","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"This problem has a GMP formulation in terms, where we optimize over one single measure  colorredmu and Gamma=1:","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"beginarrayc l\nmin_colorredmu   int colorbluef(x) dcolorredmu(x)\n int colorblue1dcolorredmu(x) = colorgreen1\n textsupp(colorredmu)subseteqcolorblueK\nendarray","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"Note that instead of optimizing over colorredxincolorblueK, the variable of the GMP is the measure colorredmu, hence turning a non-linear problem into a linear one. ","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"The equivalence of both problems can be seen as follows: First note, that for every xincolorblueK, the Dirac measure delta_x is a probability measure supported in colorblueK and hence feasible for the GMP formulation. Together with the equality colorbluef(x) = int colorbluefddelta_x this shows that the optimal value of the GMP formulation is always smaller than the one of the polynomial optimization problem. ","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"For the other inequality let colorredf^ast denote the global minimum of colorbluef on colorblueK and let colorredmu^ast be the optimal measure for the GMP formulation. Then","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"int colorbluef dcolorredmu^astgeq intcolorredf^ast dcolorredmu^ast= colorredf^astint colorblue1 dcolorredmu^ast = colorredf^ast colorgreen1 = colorredf^ast","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"showing that the optimal value of the GMP formulation is always bigger than the one of the polynomial optimization problem - and in combination with the first part, equivalence of both problems.","category":"page"},{"location":"gmp/","page":"The Generalized Moment Problem","title":"The Generalized Moment Problem","text":"In MomentOpt.jl this GMP can be modeled as demonstrated in polopt in the example folder.","category":"page"},{"location":"blackbox/#Behind-the-scenes-of-MomentOpt.jl","page":"What's in the box?","title":"Behind the scenes of MomentOpt.jl","text":"","category":"section"},{"location":"blackbox/","page":"What's in the box?","title":"What's in the box?","text":"MomentOpt is build to make contributing and extanding its functionality easy. In this part we explain how to extend MomentOpt.","category":"page"},{"location":"started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"started/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"started/","page":"Getting started","title":"Getting started","text":"MomentOpt is a package for Julia. In order to use it you need to download and install Julia first. Instructions on how to do this can be found here. ","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"Once Julia is installed, MomentOpt can be added through Julia's internal package manager.","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"$ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.4.1 (2020-04-1)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> ]\n\npkg> add MomentOpt","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"MomentOpt uses MultivariatePolynomials to model polynomial variables. The user can choose between different implementations for this polynomial interface. We recommend DynamicPolynomials:","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"pkg> add DynamicPolynomials","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"Having installed these two packages we could start modelling with MomentOpt. However, to be able to compute approximations, we need to install at least one solver. A comprehensive list of possible solvers can be found on the JuMP website.  As an open source SDP solver we could install CSDP:","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"pkg> add CSDP","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"Once these packages have been added, they do not need to be added again when starting a new session. In case you are using Jupyter notebooks to run Julia, the syntax might slightly vary. Please refer to the IJulia documentation. ","category":"page"},{"location":"started/#First-steps","page":"Getting started","title":"First steps","text":"","category":"section"},{"location":"started/","page":"Getting started","title":"Getting started","text":"To start your session open julia and load MomentOpt, an implementation of MultivariatePolynomials and an SDP solver, e.g.","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> using MomentOpt\njulia> using DynamicPolynomials\njulia> using CSDP","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"The first thing you would probably want to do, is to define the variables your measures will be acting on. In DynamicPolynomials we can use the @polyvar macro to do so:","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> @polyvar x y z\n(x, y, z)","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"Now we can start modeling our generalized moment problem. The modeling process is consitent with JuMP.jl. In particular, we always start by building a model:","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> gmp = GMPModel()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nConstraints: 0\nApproxmation mode: DUAL_STRENGTHEN_MODE()\nMaximum degree of data: 0\nDegree for approximation 0\nSolver for approximation: No optimizer attached.","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"As you can see gmp is an abstract JuMP model that currently represents a feasibility problem without any variables or constraints. The next three lines consider the specifications for the approximation and will be discussed later. Note that no optimizer has been attached to the model. To do so, we can do","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> set_optimizer(gmp, CSDP.Optimizer)\njulia> gmp\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nConstraints: 0\nApproxmation mode: DUAL_STRENGTHEN_MODE()\nMaximum degree of data: 0\nDegree for approximation 0\nSolver for approximation: CSDP","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"Alternatively, we could have attached the optimizer from the beginning by defining","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> gmp = GMPModel(CSDP.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nConstraints: 0\nApproxmation mode: DUAL_STRENGTHEN_MODE()\nMaximum degree of data: 0\nDegree for approximation 0\nSolver for approximation: CSDP","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"The variables of a generalized moment problem are measures. To add a measure to our model, we can do","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> @variable gmp mu Meas([x, y])\nmu","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"This is following the JuMP syntax, i.e., we first specify the model, than a name for our variable, and then specify that the new variable represents a measure acting on the polynomial variables x and y. It is mandatory to define on which variables a measure is acting. The polynomial variables of a measure variable can be querried via ","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> variables(mu)\n2-element Array{PolyVar{true},1}:\n x\n y","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"The most important keyword argument of the Meas() constructor is support which determines the semialgebraic set which contains the support of the measure variable:","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> @variable gmp nu Meas([x,y], support = @set(1-x^2-y^2>=0))\nnu\njulia> support(nu)\nBasic semialgebraic Set defined by no equality\n1 inequalitty\n -x^2 - y^2 + 1 ≥ 0","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"For more information on generating semi-algebraic sets via the @set macro we refer to SemiAlgebraicSets.jl. The remaining keywords are discussed in the documentation of Meas. ","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"Note that you can create anonymous measure variables or containers of measure variables","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> phi = @variable gmp [1:2] Meas([x,y,z])\n2-element Array{GMPVariableRef{MomentOpt.AbstractGMPMeasure},1}:\n noname\n noname\njulia> vars = [x, y, z]\njulia> psi = @variable gmp [i = 1:3] Meas([vars[i]]; support = @set(vars[i]^2 <= 1))\n3-element Array{GMPVariableRef{MomentOpt.AbstractGMPMeasure},1}:\n noname\n noname\n noname\njulia> support.(psi)\n3-element Array{BasicSemialgebraicSet{Int64,Polynomial{true,Int64},FullSpace},1}:\n { (x) | -x^2 + 1 ≥ 0 }\n { (y) | -y^2 + 1 ≥ 0 }\n { (z) | -z^2 + 1 ≥ 0 }","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"Note that the . behind support broadcasts the function to each element of the vector psi.  If we look at our model again, we find that mu and nu have been registered in the model.","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> gmp\nA JuMP Model\nFeasibility problem with:\nVariables: 7\nConstraints: 0\nApproxmation mode: DUAL_STRENGTHEN_MODE()\nMaximum degree of data: 2\nDegree for approximation 2\nSolver for approximation: CSDP\nNames registered in the model: mu, nu","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"We cannot add a new object with names that are alrady registered:","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> @variable gmp mu Meas([x, y])\nERROR: An object of name mu is already attached to this model. If this is intended, \nconsider using the anonymous construction syntax, e.g., x = @variable(model, [1:N], ...) \nwhere the name of the object does not appear inside the macro.","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"Also note, that we have registered 6 variables and that the maximum degree of data is 2 now, since the definition of the measure nu involved a polynomial of degree 2. The maximum degree of data will update automatically, when adding variables or constraints. The degree for approximation is always at least as large as the degree of the data and is updated automatically:","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> set_approximation_degree(gmp, 4)\njulia> gmp\nA JuMP Model\nFeasibility problem with:\nVariables: 7\nConstraints: 0\nApproxmation mode: DUAL_STRENGTHEN_MODE()\nMaximum degree of data: 2\nDegree for approximation 4\nSolver for approximation: CSDP\nNames registered in the model: mu, nu\n\njulia> set_approximation_degree(gmp, 1)\n┌ Warning: Requested approximation degree 1 is too low to cover all data. \nThe approximation degree has been set to the minimal value possible and now is 2.","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"Next we can add constraints to our model. However, we will start with a new model. A typical constraint for generalized moment problems is that the measure variable is a probability measure, which is added as follwos","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> gmp = GMPModel(CSDP.Optimizer);\njulia> @variable gmp mu Meas([x], support = @set(x-x^2>=0));\njulia> @constraint gmp Mom(1, mu) == 1\n⟨1, mu⟩ = 1.0","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"Here Mom(1, mu) expressed the integral of 1 with respect to mu. Constraints can have names","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> @constraint gmp xcon Mom(x, mu) == 0.5;\njulia> xcon\nxcon : ⟨x, mu⟩ = 0.5\njulia> @constraint gmp xicon[i = 2:4] Mom(x^i, mu) .== 1/(i+1);\njulia> xicon[2]\n⟨x², mu⟩ = 0.3333333333333333\n","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"So far we have only considered moment constraints. MomentOpt also supports measure constraints:","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> lambda = lebesgue_measure_box(x => [0, 1])\nAnalyticMeasure","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"defines an AnalyticMeasure, representing the Lebesgue measure on [0, 1]. It can be used to integrate polynomials","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> integrate(x^2 - x + 1, lambda)\n0.8333333333333333\njulia integrate.(monoimals([x], 0:4), lambda)\n5-element Array{Float64,1}:\n 0.2\n 0.25\n 0.3333333333333333\n 0.5\n 1.0","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"but it can also be used to define measure constraints:","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> gmp = GMPModel(CSDP.Optimizer);\njulia> @variable gmp mu Meas([x,y], support = @set(1-x^2-y^2>=0));\njulia> @variable gmp nu Meas([x,y], support = @set(1-x^2>= 0 && 1-y^2>=0));\njulia> gmp\nA JuMP Model\nFeasibility problem with:\nVariables: 2\nConstraint: 1\nApproxmation mode: DUAL_STRENGTHEN_MODE()\nMaximum degree of data: 2\nDegree for approximation 2\nSolver for approximation: CSDP\nNames registered in the model: mu, nu\njulia> lambda = lebesgue_measure_box(x => [-1, 1], y => [-1, 1]; normalize = true)\njulia> mc = @constraint gmp mu + nu == lambda\nmu + nu = AnalyticMeasure\njulia> gmp\nA JuMP Model\nFeasibility problem with:\nVariables: 2\nConstraint: 1\nApproxmation mode: DUAL_STRENGTHEN_MODE()\nMaximum degree of data: 2\nDegree for approximation 2\nSolver for approximation: CSDP\nNames registered in the model: mu, nu","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"Note that mc did not change the degree of data. The degree of a measure constraint is always equal to the approximation degree and determined at the optimization call.","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"To finish this introduction on modeling with MomentOpt, we have to set an objective function. This can be done via","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> @objective gmp Max Mom(1, mu) \n⟨1, mu⟩","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"The model now can be approximated by setting an approximation order (it defaults to the maximum degree of data). In this example we also suppress the output of CSDP:","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> set_approximation_degree(gmp, 10)\njulia> set_silent(gmp);\njulia> optimize!(gmp)","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"We can querry the stats of the solved approximation","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> objective_value(gmp)\n0.9369024582093924\njulia> termination_status(gmp)\nOPTIMAL::TerminationStatusCode = 1\njulia> raw_status(gmp)\n\"Problem solved to optimality.\"","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"The solution can be expected by calling ","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> measure(mu)\nMultivariateMoments.Measure{Float64,Monomial{true},MonomialVector{true}}([0.062044293013069955, 1.818408257153911e-19, 0.01273398937697667, 4.4781213912861547e-20, 0.0064424590352839825, 2.0217159884897534e-21, 0.006442459035519992, -4.815750725967947e-20, 0.012733989378712668, -2.0895884615236935e-19  …  -3.8109683913485666e-18, 1.865988294254163e-18, -3.515461570762854e-18, 2.056500523116538e-18, 0.2816658397255027, -7.275476044869635e-21, 0.28166583972970993, -5.312847305918446e-18, 2.8599527338155522e-18, 0.9369024582093924], Monomial{true}[x¹⁰, x⁹y, x⁸y², x⁷y³, x⁶y⁴, x⁵y⁵, x⁴y⁶, x³y⁷, x²y⁸, xy⁹  …  x³, x²y, xy², y³, x², xy, y², x, y, 1])","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"This returns a sequence of moments. The dual to our constraint mc is a polynomial of degree 10 in the variables x and y.","category":"page"},{"location":"started/","page":"Getting started","title":"Getting started","text":"julia> poly = dual(mc);\njulia> maxdegree(poly)\n10\njuila> variables(poly) \n2-element Array{PolyVar{true},1}:\n x\n y","category":"page"},{"location":"#MomentOpt.jl-Modelization-and-Conic-Relaxations-for-Generalized-Moment-Problems","page":"Introduction","title":"MomentOpt.jl - Modelization and Conic Relaxations for Generalized Moment Problems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"MomentOpt.jl is a Julia package to model Generalized Moment Problems and to approximate solutions via conic relaxations as it is described in Moments, Positive Polynomials and Their Applications or more recently in The Moment-SOS Hierarchy. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The two main ideas of MomentOpt.jl are ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"use a highlevel syntax to define Generalized Moment Problems easily\nprovide different options to approximate solutions and switch between different formulations easily.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"MomentOpt.jl is implemented as a JuMP.jl extension. In particular it uses the same syntax for modeliztion. For example:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"m = GMPModel() generates an empty model representing a generalized moment problem\n@variable m Meas([x, y]; kwargs...) args... adds a measure variable to m. \n@constraint m args... adds constraints to m. \nset_optimizer(m, optimizer) can be used to set the optimizer. Alternatively, one can define the optimizer from the beginning m = GMPModel(optimizer).\noptimize!(m) is used to approximate a solution to m","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As a JuMP extension all numerical solvers available through JuMP are available to be used in MomentOpt, too. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"MomentOpt.jl uses the MultivariatePolynomials.jl interface to represent polynomials and moments. We recommend using the implementation DynamicPolynomials.jl.","category":"page"},{"location":"#Content","page":"Introduction","title":"Content","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"    Pages = [\"gmp.md\"]\n    Depth = 2","category":"page"},{"location":"#How-to-cite","page":"Introduction","title":"How to cite","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"See citation.bib.","category":"page"}]
}
